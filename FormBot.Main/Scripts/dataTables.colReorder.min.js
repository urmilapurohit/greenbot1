/*
   Copyright 2010-2017 SpryMedia Ltd.

 This source file is free software, available under the following license:
   MIT license - http://datatables.net/license/mit

 This source file is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.

 For details please refer to: http://www.datatables.net
 ColReorder 1.4.1
 Â©2010-2017 SpryMedia Ltd - datatables.net/license
*/
(function (d) { "function" === typeof define && define.amd ? define(["jquery", "datatables.net"], function (t) { return d(t, window, document) }) : "object" === typeof exports ? module.exports = function (t, n) { t || (t = window); n && n.fn.dataTable || (n = require("datatables.net")(t, n).$); return d(n, t, t.document) } : d(jQuery, window, document) })(function (d, t, n, w) {
    function v(a) { for (var b = [], c = 0, f = a.length; c < f; c++) b[a[c]] = c; return b } function u(a, b, c) { b = a.splice(b, 1)[0]; a.splice(c, 0, b) } function x(a, b, c) {
        for (var f = [], d = 0, g = a.childNodes.length; d <
        g; d++) 1 == a.childNodes[d].nodeType && f.push(a.childNodes[d]); b = f[b]; null !== c ? a.insertBefore(b, f[c]) : a.appendChild(b)
    } var y = d.fn.dataTable; d.fn.dataTableExt.oApi.fnColReorder = function (a, b, c, f, h) {
        var g, p, l = a.aoColumns.length; var r = function (a, b, c) { if (a[b] && "function" !== typeof a[b]) { var d = a[b].split("."), f = d.shift(); isNaN(1 * f) || (a[b] = c[1 * f] + "." + d.join(".")) } }; var n = 0; d(a.aoColumns).each(function (b) { 1 == a.aoColumns[b].bVisible && n++ }); if (0 != b && 0 != c) {
            if (6 == UserTypeID || "true" == isAssignSSC && (4 == UserTypeID &&
            "true" == IsSSCReseller || 8 == UserTypeID && "false" == IsSubContractor && "true" == IsSSCReseller)) if (b == n - 1 || c == n - 1) return; if (!(0 > b || b >= n || 0 > c || c >= n || b == c)) if (0 > b || b >= l) this.oApi._fnLog(a, 1, "ColReorder 'from' index is out of bounds: " + b); else if (0 > c || c >= l) this.oApi._fnLog(a, 1, "ColReorder 'to' index is out of bounds: " + c); else {
                var k = []; var e = 0; for (g = l; e < g; e++) k[e] = e; u(k, b, c); var q = v(k); e = 0; for (g = a.aaSorting.length; e < g; e++) a.aaSorting[e][0] = q[a.aaSorting[e][0]]; if (null !== a.aaSortingFixed) for (e = 0, g = a.aaSortingFixed.length; e <
                g; e++) a.aaSortingFixed[e][0] = q[a.aaSortingFixed[e][0]]; e = 0; for (g = l; e < g; e++) { var m = a.aoColumns[e]; k = 0; for (p = m.aDataSort.length; k < p; k++) m.aDataSort[k] = q[m.aDataSort[k]]; m.idx = q[m.idx] } d.each(a.aLastSort, function (b, c) { a.aLastSort[b].src = q[c.src] }); e = 0; for (g = l; e < g; e++) m = a.aoColumns[e], "number" == typeof m.mData ? m.mData = q[m.mData] : d.isPlainObject(m.mData) && (r(m.mData, "_", q), r(m.mData, "filter", q), r(m.mData, "sort", q), r(m.mData, "type", q)); if (a.aoColumns[b].bVisible) {
                    r = this.oApi._fnColumnIndexToVisible(a, b);
                    p = null; for (e = c < b ? c : c + 1; null === p && e < l;) p = this.oApi._fnColumnIndexToVisible(a, e), e++; k = a.nTHead.getElementsByTagName("tr"); e = 0; for (g = k.length; e < g; e++) x(k[e], r, p); if (null !== a.nTFoot) for (k = a.nTFoot.getElementsByTagName("tr"), e = 0, g = k.length; e < g; e++) x(k[e], r, p); e = 0; for (g = a.aoData.length; e < g; e++) null !== a.aoData[e].nTr && x(a.aoData[e].nTr, r, p)
                } u(a.aoColumns, b, c); e = 0; for (g = l; e < g; e++) a.oApi._fnColumnOptions(a, e, {}); u(a.aoPreSearchCols, b, c); e = 0; for (g = a.aoData.length; e < g; e++) {
                    p = a.aoData[e]; if (m = p.anCells) for (u(m,
                    b, c), k = 0, r = m.length; k < r; k++) m[k] && m[k]._DT_CellIndex && (m[k]._DT_CellIndex.column = k); "dom" !== p.src && d.isArray(p._aData) && u(p._aData, b, c)
                } e = 0; for (g = a.aoHeader.length; e < g; e++) u(a.aoHeader[e], b, c); if (null !== a.aoFooter) for (e = 0, g = a.aoFooter.length; e < g; e++) u(a.aoFooter[e], b, c); (h || h === w) && d.fn.dataTable.Api(a).rows().invalidate(); e = 0; for (g = l; e < g; e++) d(a.aoColumns[e].nTh).off("click.DT"), this.oApi._fnSortAttachListener(a, a.aoColumns[e].nTh, e); d(a.oInstance).trigger("column-reorder.dt", [a, {
                    from: b, to: c, mapping: q,
                    drop: f, iFrom: b, iTo: c, aiInvertMapping: q
                }])
            }
        }
    }; var l = function (a, b) {
        var c = (new d.fn.dataTable.Api(a)).settings()[0]; if (c._colReorder) return c._colReorder; !0 === b && (b = {}); var f = d.fn.dataTable.camelToHungarian; f && (f(l.defaults, l.defaults, !0), f(l.defaults, b || {})); this.s = { dt: null, init: d.extend(!0, {}, l.defaults, b), fixed: 0, fixedRight: 0, reorderCallback: null, mouse: { startX: -1, startY: -1, offsetX: -1, offsetY: -1, target: -1, targetIndex: -1, fromIndex: -1 }, aoTargets: [] }; this.dom = { drag: null, pointer: null }; this.s.dt = c; this.s.dt._colReorder =
        this; this._fnConstruct(); return this
    }; d.extend(l.prototype, {
        fnReset: function () { this._fnOrderColumns(this.fnOrder()); return this }, fnGetCurrentOrder: function () { return this.fnOrder() }, fnOrder: function (a, b) { var c = [], f, h = this.s.dt.aoColumns; if (a === w) { var g = 0; for (f = h.length; g < f; g++) c.push(h[g]._ColReorder_iOrigCol); return c } if (b) { h = this.fnOrder(); g = 0; for (f = a.length; g < f; g++) c.push(d.inArray(a[g], h)); a = c } this._fnOrderColumns(v(a)); return this }, fnTranspose: function (a, b) {
            b || (b = "toCurrent"); var c = this.fnOrder(),
            f = this.s.dt.aoColumns; return "toCurrent" === b ? d.isArray(a) ? d.map(a, function (a) { return d.inArray(a, c) }) : d.inArray(a, c) : d.isArray(a) ? d.map(a, function (a) { return f[a]._ColReorder_iOrigCol }) : f[a]._ColReorder_iOrigCol
        }, _fnConstruct: function () {
            var a = this, b = this.s.dt.aoColumns.length, c = this.s.dt.nTable, f; this.s.init.iFixedColumns && (this.s.fixed = this.s.init.iFixedColumns); this.s.init.iFixedColumnsLeft && (this.s.fixed = this.s.init.iFixedColumnsLeft); this.s.fixedRight = this.s.init.iFixedColumnsRight ? this.s.init.iFixedColumnsRight :
            0; this.s.init.fnReorderCallback && (this.s.reorderCallback = this.s.init.fnReorderCallback); for (f = 0; f < b; f++) f > this.s.fixed - 1 && f < b - this.s.fixedRight && this._fnMouseListener(f, this.s.dt.aoColumns[f].nTh), this.s.dt.aoColumns[f]._ColReorder_iOrigCol = f; this.s.dt.oApi._fnCallbackReg(this.s.dt, "aoStateSaveParams", function (b, c) { a._fnStateSave.call(a, c) }, "ColReorder_State"); var h = null; this.s.init.aiOrder && (h = this.s.init.aiOrder.slice()); this.s.dt.oLoadedState && "undefined" != typeof this.s.dt.oLoadedState.ColReorder &&
            this.s.dt.oLoadedState.ColReorder.length == this.s.dt.aoColumns.length && (h = this.s.dt.oLoadedState.ColReorder); if (h) if (a.s.dt._bInitComplete) b = v(h), a._fnOrderColumns.call(a, b); else { var g = !1; d(c).on("draw.dt.colReorder", function () { if (!a.s.dt._bInitComplete && !g) { g = !0; var b = v(h); a._fnOrderColumns.call(a, b) } }) } else this._fnSetColumnIndexes(); d(c).on("destroy.dt.colReorder", function () {
                d(c).off("destroy.dt.colReorder draw.dt.colReorder"); d(a.s.dt.nTHead).find("*").off(".ColReorder"); d.each(a.s.dt.aoColumns,
                function (a, b) { d(b.nTh).removeAttr("data-column-index") }); a.s.dt._colReorder = null; a.s = null
            })
        }, _fnOrderColumns: function (a) {
            var b = !1; if (a.length != this.s.dt.aoColumns.length) this.s.dt.oInstance.oApi._fnLog(this.s.dt, 1, "ColReorder - array reorder does not match known number of columns. Skipping."); else {
                for (var c = 0, f = a.length; c < f; c++) { var h = d.inArray(c, a); c != h && (u(a, h, c), this.s.dt.oInstance.fnColReorder(h, c, !0, !1), b = !0) } d.fn.dataTable.Api(this.s.dt).rows().invalidate(); this._fnSetColumnIndexes(); b && ("" ===
                this.s.dt.oScroll.sX && "" === this.s.dt.oScroll.sY || this.s.dt.oInstance.fnAdjustColumnSizing(!1), this.s.dt.oInstance.oApi._fnSaveState(this.s.dt), null !== this.s.reorderCallback && this.s.reorderCallback.call(this))
            }
        }, _fnStateSave: function (a) {
            var b, c, f = this.s.dt.aoColumns; a.ColReorder = []; if (a.aaSorting) {
                for (b = 0; b < a.aaSorting.length; b++) a.aaSorting[b][0] = f[a.aaSorting[b][0]]._ColReorder_iOrigCol; var h = d.extend(!0, [], a.aoSearchCols); b = 0; for (c = f.length; b < c; b++) {
                    var g = f[b]._ColReorder_iOrigCol; a.aoSearchCols[g] =
                    h[b]; a.abVisCols[g] = f[b].bVisible; a.ColReorder.push(g)
                }
            } else if (a.order) { for (b = 0; b < a.order.length; b++) a.order[b][0] = f[a.order[b][0]]._ColReorder_iOrigCol; h = d.extend(!0, [], a.columns); b = 0; for (c = f.length; b < c; b++) g = f[b]._ColReorder_iOrigCol, a.columns[g] = h[b], a.ColReorder.push(g) }
        }, _fnMouseListener: function (a, b) { var c = this; d(b).on("mousedown.ColReorder", function (a) { c._fnMouseDown.call(c, a, b) }).on("touchstart.ColReorder", function (a) { c._fnMouseDown.call(c, a, b) }) }, _fnMouseDown: function (a, b) {
            var c = this, f =
            d(a.target).closest("th, td").offset(), h = parseInt(d(b).attr("data-column-index"), 10); h !== w && (this.s.mouse.startX = this._fnCursorPosition(a, "pageX"), this.s.mouse.startY = this._fnCursorPosition(a, "pageY"), this.s.mouse.offsetX = this._fnCursorPosition(a, "pageX") - f.left, this.s.mouse.offsetY = this._fnCursorPosition(a, "pageY") - f.top, this.s.mouse.target = this.s.dt.aoColumns[h].nTh, this.s.mouse.targetIndex = h, this.s.mouse.fromIndex = h, this._fnRegions(), d(n).on("mousemove.ColReorder touchmove.ColReorder", function (a) {
                c._fnMouseMove.call(c,
                a)
            }).on("mouseup.ColReorder touchend.ColReorder", function (a) { c._fnMouseUp.call(c, a) }))
        }, _fnMouseMove: function (a) {
            if (null === this.dom.drag) { if (5 > Math.pow(Math.pow(this._fnCursorPosition(a, "pageX") - this.s.mouse.startX, 2) + Math.pow(this._fnCursorPosition(a, "pageY") - this.s.mouse.startY, 2), .5)) return; this._fnCreateDragNode() } this.dom.drag.css({ left: this._fnCursorPosition(a, "pageX") - this.s.mouse.offsetX, top: this._fnCursorPosition(a, "pageY") - this.s.mouse.offsetY }); for (var b = !1, c = this.s.mouse.toIndex, d = 1, h =
            this.s.aoTargets.length; d < h; d++) if (this._fnCursorPosition(a, "pageX") < this.s.aoTargets[d - 1].x + (this.s.aoTargets[d].x - this.s.aoTargets[d - 1].x) / 2) { this.dom.pointer.css("left", this.s.aoTargets[d - 1].x); this.s.mouse.toIndex = this.s.aoTargets[d - 1].to; b = !0; break } b || (this.dom.pointer.css("left", this.s.aoTargets[this.s.aoTargets.length - 1].x), this.s.mouse.toIndex = this.s.aoTargets[this.s.aoTargets.length - 1].to); this.s.init.bRealtime && c !== this.s.mouse.toIndex && (this.s.dt.oInstance.fnColReorder(this.s.mouse.fromIndex,
            this.s.mouse.toIndex, !1), this.s.mouse.fromIndex = this.s.mouse.toIndex, this._fnRegions())
        }, _fnMouseUp: function (a) {
            d(n).off(".ColReorder"); null !== this.dom.drag && (this.dom.drag.remove(), this.dom.pointer.remove(), this.dom.drag = null, this.dom.pointer = null, this.s.dt.oInstance.fnColReorder(this.s.mouse.fromIndex, this.s.mouse.toIndex, !0), this._fnSetColumnIndexes(), "" === this.s.dt.oScroll.sX && "" === this.s.dt.oScroll.sY || this.s.dt.oInstance.fnAdjustColumnSizing(!1), this.s.dt.oInstance.oApi._fnSaveState(this.s.dt),
            null !== this.s.reorderCallback && this.s.reorderCallback.call(this))
        }, _fnRegions: function () {
            var a = this.s.dt.aoColumns; this.s.aoTargets.splice(0, this.s.aoTargets.length); this.s.aoTargets.push({ x: d(this.s.dt.nTable).offset().left, to: 0 }); for (var b = 0, c = this.s.aoTargets[0].x, f = 0, h = a.length; f < h; f++) f != this.s.mouse.fromIndex && b++, a[f].bVisible && "none" !== a[f].nTh.style.display && (c += d(a[f].nTh).outerWidth(), this.s.aoTargets.push({ x: c, to: b })); 0 !== this.s.fixedRight && this.s.aoTargets.splice(this.s.aoTargets.length -
            this.s.fixedRight); 0 !== this.s.fixed && this.s.aoTargets.splice(0, this.s.fixed)
        }, _fnCreateDragNode: function () {
            var a = "" !== this.s.dt.oScroll.sX || "" !== this.s.dt.oScroll.sY, b = this.s.dt.aoColumns[this.s.mouse.targetIndex].nTh, c = b.parentNode, f = c.parentNode, h = f.parentNode, g = d(b).clone(); this.dom.drag = d(h.cloneNode(!1)).addClass("DTCR_clonedTable").append(d(f.cloneNode(!1)).append(d(c.cloneNode(!1)).append(g[0]))).css({ position: "absolute", top: 0, left: 0, width: d(b).outerWidth(), height: d(b).outerHeight() }).appendTo("body");
            this.dom.pointer = d("<div></div>").addClass("DTCR_pointer").css({ position: "absolute", top: a ? d("div.dataTables_scroll", this.s.dt.nTableWrapper).offset().top : d(this.s.dt.nTable).offset().top, height: a ? d("div.dataTables_scroll", this.s.dt.nTableWrapper).height() : d(this.s.dt.nTable).height() }).appendTo("body")
        }, _fnSetColumnIndexes: function () { d.each(this.s.dt.aoColumns, function (a, b) { d(b.nTh).attr("data-column-index", a) }) }, _fnCursorPosition: function (a, b) {
            return -1 !== a.type.indexOf("touch") ? a.originalEvent.touches[0][b] :
            a[b]
        }
    }); l.defaults = { aiOrder: null, bRealtime: !0, iFixedColumnsLeft: 0, iFixedColumnsRight: 0, fnReorderCallback: null }; l.version = "1.4.1"; d.fn.dataTable.ColReorder = l; d.fn.DataTable.ColReorder = l; "function" == typeof d.fn.dataTable && "function" == typeof d.fn.dataTableExt.fnVersionCheck && d.fn.dataTableExt.fnVersionCheck("1.10.8") ? d.fn.dataTableExt.aoFeatures.push({
        fnInit: function (a) {
            var b = a.oInstance; a._colReorder ? b.oApi._fnLog(a, 1, "ColReorder attempted to initialise twice. Ignoring second") : (b = a.oInit, new l(a, b.colReorder ||
            b.oColReorder || {})); return null
        }, cFeature: "R", sFeature: "ColReorder"
    }) : alert("Warning: ColReorder requires DataTables 1.10.8 or greater - www.datatables.net/download"); d(n).on("preInit.dt.colReorder", function (a, b) { if ("dt" === a.namespace) { var c = b.oInit.colReorder, f = y.defaults.colReorder; if (c || f) f = d.extend({}, c, f), !1 !== c && new l(b, f) } }); d.fn.dataTable.Api.register("colReorder.reset()", function () { return this.iterator("table", function (a) { a._colReorder.fnReset() }) }); d.fn.dataTable.Api.register("colReorder.order()",
    function (a, b) { return a ? this.iterator("table", function (c) { c._colReorder.fnOrder(a, b) }) : this.context.length ? this.context[0]._colReorder.fnOrder() : null }); d.fn.dataTable.Api.register("colReorder.transpose()", function (a, b) { return this.context.length && this.context[0]._colReorder ? this.context[0]._colReorder.fnTranspose(a, b) : a }); d.fn.dataTable.Api.register("colReorder.move()", function (a, b, c, d) { this.context.length && this.context[0]._colReorder.s.dt.oInstance.fnColReorder(a, b, c, d); return this }); return l
});